---
title: "ICTIO 框架：工程化的提示词设计方法"
date: 2025-01-03
categories: ["技术"]
tags: ["Prompt Engineering", "最佳实践", "框架设计", "工程化"]
draft: false
description: "提示词没有系统思路？用 ICTIO 框架快速组织结构、加快迭代、降低维护成本。"
---

写提示词最常见的问题是：没有系统思路，堆砌各种需求，最后结构混乱、难以调整。经过多个项目的实践，我总结出了 ICTIO 框架——一套工程化的提示词设计方法。它的核心思想很简单：用五个层次的 Block 来组织提示词，按照任务类型选择必需的层次，避免过度设计。

这个框架的作用不在于追求某个特定指标，而在于让提示词写得有结构、快速填充内容、容易迭代。

这篇文章分享三个内容：框架的五个 Block 层次，六种常见任务的最小化配置，以及设计时应该遵循的原则。

## 五层 Block 定义

**Instruction** - 任务目标与执行逻辑  
定义做什么、怎么做。是提示词的核心逻辑层，所有任务都必需。

**Context** - 上下文信息与已有数据  
存放历史记录、用户信息、参数列表、背景知识等实际数据。需要时添加。

**Tools** - 工具调用规范  
定义可用工具、参数说明、返回值格式。仅当任务涉及工具调用时需要。

**Input** - 入参定义  
明确输入的格式、字段、约束。当需要严格定义输入时添加。

**Output** - 出参格式与约束  
规定输出的结构、长度、风格。几乎所有任务都需要。

## 按任务类型配置

**参数提取**  
必需：Instruction + Context + Input + Output  
特点：单轮交互，直接提取参数并调用工具，无对话轮次  
示例：从用户请求中提取目标城市、出发日期等参数

**意图分类 / 实体抽取**  
必需：Instruction + Input + Output  
可选：Context（分类标签集合或上下文约束）  
特点：识别和提取，不涉及工具调用，纯文本理解

**角色扮演 / 文本生成**  
必需：Instruction + Output  
可选：Context（用户偏好、写作风格、约束条件）  
特点：内容生成，格式或风格约束，无需工具

**Agent Chatbot（带工具执行能力）**  
必需：Instruction + Context + Tools + Input + Output  
特点：多轮对话，执行工具调用，有状态管理，最复杂的配置

**知识库问答 / 检索增强**  
必需：Instruction + Context + Output  
可选：Input（显式定义查询格式）  
特点：基于已有知识或召回内容生成回答

**复杂决策 / 推理**  
必需：Instruction + Context + Output  
特点：多因素权衡，需要明确推理过程

## 工程化设计的四个原则

### 1. 最小化原则

只加必需的 Block，不要超度设计。参数提取不需要 Tools，意图分类不需要 Context，这样做有两个好处：

其一是减少模型的处理负担。冗余的信息会分散注意力，降低模型对核心指令的理解。

其二是便于快速迭代。Block 越少，改动越直接，反馈周期越快。这对早期探索很重要。

### 2. 分工清晰

每个 Block 只做一件事。Context 放数据，Instruction 放逻辑，Tools 放接口说明，Output 放格式约束。

分工模糊是提示词难以维护的主要原因。当逻辑和数据混在一起，改某个参数可能意外影响其他行为。好的分工结构让即使是非技术人员也能理解提示词的各部分职责。

### 3. 占位符优先，策略优先

**用占位符而非硬编码。** 采用 {{language}}、{{user_query}}、{{history}} 等占位符，让提示词可复用且参数化。不要写死具体的值。

**用策略描述而非硬编码句子。** 这是最常见的错误。

反面做法：写死完整句子：
```
"抱歉呀！当前服务临时波动，暂时无法为你返回结果。我们正在紧急排查修复..."
```

该做法的问题是无法随语言变化。用户语言为日语时，该句子还是中文。

正确做法：以策略描述要求：
```
"工具调用异常时用 {{language}} 语言给出一句简洁友好的错误提示"
```

这样模型可以根据实际参数自动生成符合要求的表达。

核心区别：硬编码是固定表述，策略是方向性指导。

### 4. 指令原子化与清晰度

**原子化指令。** 每条指令仅表达一个逻辑单元。使用"当...时..."的格式，确保规则相互独立。

反例："用户明确提及或隐含描述风格时从列表匹配，缺失时选择最符合的风格"（逻辑耦合）

正例："从列表匹配对应的值，无法匹配则不填"（逻辑独立）

**柔中带刚。** 关键流程需清晰无歧义（如"直接调用工具"），而边界规则可以保留灵活空间（如"无法匹配"而非穷举所有情况）。既堵住了已知漏洞，又不过度约束。

## 实战启发

**最小化配置带来的好处。** 只写必需的 Block 听起来简单，但在实际操作中很容易破坏。团队成员会想加额外的约束、背景信息、示例，这些都是出于好意。关键是要有定力——识别真正的需求，拒绝不必要的冗余。

**分工清晰的力量。** 提示词代码化后，分工清晰变得容易追踪问题。比如参数提取准确率不够，可以快速定位是 Instruction 的逻辑问题、Input 的定义不清、还是 Output 的约束冲突。不清晰的提示词时常让你不知道改什么才能改对。

**文档化本身就是优化。** 把提示词用 Block 组织后，它变成了可读的、可维护的代码。新成员能快速理解，Code Review 时也能指出问题。这本身就提升了质量。

## 总结

ICTIO 框架本质上是提示词工程化的一套标准化方法。它不追求某个特定的性能指标，而是提供结构、加快迭代、降低维护成本。

五个 Block 层次提供了足够的灵活性，六种常见任务的最小化配置让你不用每次都从零开始思考。四个设计原则确保提示词写得清晰、可复用、易维护。

对于任何涉及多个提示词版本迭代、多人协作的项目，这套方法都有直接的价值。